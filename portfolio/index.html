<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="format-detection" content="telephone=no">
	<link rel="preload" as="style" type="text/css" media="all" href="/fonts/equity-heavy.css">
	<link rel="stylesheet" type="text/css" media="all" href="/fonts/equity-heavy.css">
	<title>Portfolio: ME460 DP1</title>
    <!--<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>-->
	<link rel="stylesheet" type="text/css" href="css/index.css">
	<style type="text/css">
		body.hidden { opacity: 0; }
        img {
            /*For some reason this only works if in the head, not within index.css
            TODO: Determine what's overriding in between...*/
            width: 100%;
            height: 100%;
            padding-bottom: 0.2em;
            padding-top: 0.2em;
        }
        .footer {
            padding-top: 4em;
        }
        div.footer p {
            padding: 0;
            /*TODO: Fix para padding in footer. Using <br> as a workaround*/
        }

    </style>
	<!--Favicons-->
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#da532c">
	<meta name="theme-color" content="#ffffff">
</head>
<body id="body" class="body-text_equity" body-text="true">
<div id="content">
	<div id="doc">
		<topic class="small">ME460 Design Project #1: Linear Stage</topic>
		<div class="subhead small-caps" id="work">
            <a href="#work">Work description</a></div>
            <p>
                The goal of this design project is to build a linear stage with open-loop control, capable of moving 0.5kg to predefined locations along its path. This report is divided into eight sections: the <a href="#work">Work Description</a>, <a href="#principles">Principles of Operation</a>, <a href="#construction">Mechanical Construction</a>, <a href="#circuitry">Circuitry</a>, <a href="#code">Code</a>, <a href="#tests">Test Procedure</a>, <a href="#results">Test Results</a>, and <a href="#motion">Loaded Motion Cycle</a>. The above can be used as a table of contents by clicking the desired section.
            </p>
            <p>
                Work was largely organized in the same fashion as the report's heirarchy; the rails were assembled as described in the <a href="#construction">mechanical construction</a> section and code was written for initial testing (described in the <a href="#code">code</a> and <a href="#tests">test procedure</a> / <a href="#results">results</a> sections). This was followed with the implementation of a limit switch&mdash;wired in as per the <a href="#circuitry">circuitry</a> section, and the code modified accordingly. Finally, the video of the <a href="#motion">stage in motion</a> was produced, integrating all prior work and demonstrating functionality meeting that which was set out within the goals.
            </p>
        <div class="subhead small-caps" id="principles">
            <a href="#principles">Principles of operation</a></div>
            <p>
                
            </p>
        <div class="subhead small-caps" id="construction">
            <a href="#construction">Mechanical construction</a></div>
            <p>
                
            </p>
        <div class="subhead small-caps" id="circuitry">
            <a href="#circuitry">Circuitry</a></div>
            <p>
                
            </p>
        <div class="subhead small-caps" id="code">
            <a href="#code">Code</a></div>
            <pre><code>/* Zachary Weiss
** 26 Sept 2020
** Linear Rail Full & Half Step for ME460 */
#define OFF   0
#define NORTH 1
#define SOUTH 2
#define HALF  3
#define FULL  4

// globals and flags
int f_delay  = 2000,  // full step delay in micros
    h_delay  = 1000,  // half step delay in micros
    steptype = FULL;  // change between HALF and FULL
                      //   to modify step type

void setup() {
  // coil A
  pinMode(12,OUTPUT); // direction
  pinMode(3,OUTPUT);  // on/off
  pinMode(9,OUTPUT);  // brake

  // coil B
  pinMode(13,OUTPUT);
  pinMode(11,OUTPUT);
  pinMode(8,OUTPUT);

  // limit switch
  pinMode(10,INPUT_PULLUP);

  shutdown();

  Serial.begin(115200);

  // wait for user input to begin
  while(digitalRead(10));
  // allow time for button to be released, else will skip
  // first step of movement sequence that waits for
  // the limit switch to trigger
  delay(200);
}

void loop() {
  // init step and time counters,
  // define max distance in steps
  int step = 0,
      stepmax = 1200;
  double t0 = micros();
  
  // print which regime we're operating in, to contextualize
  // later data readouts
  Serial.println(steptype==FULL?"Full":"Half");

  if (steptype==FULL) {
    // 50 steps per 1 revolution
    // while switch is unpressed and count is below safety margin
    while(digitalRead(10) && step<1.2*stepmax){
      towards(step,t0);
      step++;
    }
    for (step=0;step<=stepmax;step++) {  
      away(step,t0);
    }
  }
  
  if (steptype==HALF) {
    while(digitalRead(10) && step<1.2*stepmax){
      towardsHalf(step,t0);
      step++;
    }
    for (step=0;step<=stepmax;step++) {  
      awayHalf(step,t0);
    }
  }
  
  shutdown(); // turn off all
  while(1);   // hold until reset
}

// towards stepper
void towards(int s, double t0) {
  int ss = 0; // substep counter 
  coilA(NORTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  coilA(OFF);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  coilA(SOUTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  coilA(OFF);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  if(ss!=4){Serial.println("Full stepcount issue"); shutdown(); while(1);}
}

void towardsHalf(int s, double t0) {
  int ss = 0;
  coilA(OFF);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(NORTH);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(NORTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(NORTH);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(OFF);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(SOUTH);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(SOUTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(SOUTH);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  if(ss!=8){Serial.println("Half stepcount issue"); shutdown(); while(1);}
}

// away from stepper
void away(int s, double t0) {
  int ss = 0;
  coilA(OFF);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  coilA(NORTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  coilA(OFF);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  coilA(SOUTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(f_delay);
  if(ss!=4){Serial.println("Full stepcount issue"); shutdown(); while(1);}
}

void awayHalf(int s, double t0) {
  int ss = 0;
  coilA(OFF);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(SOUTH);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(SOUTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(SOUTH);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(OFF);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(NORTH);
  coilB(NORTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(NORTH);
  coilB(OFF);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  coilA(NORTH);
  coilB(SOUTH);
  ss = readout(t0,s,ss);
  delayMicroseconds(h_delay);
  if(ss!=8){Serial.println("Half stepcount issue"); shutdown(); while(1);}
}

// case switching dependent on desired polarity
// turns off brake, selects direction and turns on/off
void coilA(int pole) {
  digitalWrite(9,LOW);
  if (pole == NORTH) {
    digitalWrite(12,HIGH);
    digitalWrite(3,HIGH);
  }
  if (pole == SOUTH) {
    digitalWrite(12,LOW);
    digitalWrite(3,HIGH);
  }
  if (pole == OFF) {
    digitalWrite(12,LOW);
    digitalWrite(3,LOW);
  }
}

void coilB(int pole) {
  digitalWrite(8,LOW);
  if (pole == NORTH) {
    digitalWrite(13,HIGH);
    digitalWrite(11,HIGH);
  }
  if (pole == SOUTH) {
    digitalWrite(13,LOW);
    digitalWrite(11,HIGH);
  }
  if (pole == OFF) {
    digitalWrite(13,LOW);
    digitalWrite(11,LOW);
  }
}

// measures current in A & B
// prints time, step #, and current
int readout(double t0, int s, int ss) {
  float i_A = float(analogRead(0)) / 1023.0 * 5.0 / 1.65 * 1000.0,
        i_B = float(analogRead(1)) / 1023.0 * 5.0 / 1.65 * 1000.0;
  int truestep = steptype==FULL ? s*4 + ss : s*8 + ss;
  Serial.println(
    String((micros()-t0)/1000000)
    +"\t"
    +String(truestep)
    +"\t"
    +String(i_A)
    +"\t"
    +String(i_B)
  );
  // increment substep
  ss+=1;
  return ss;
}

// turn all off
void shutdown() {
  digitalWrite (12,LOW);
  digitalWrite (3,LOW);
  digitalWrite (9,LOW);
  digitalWrite (13,LOW);
  digitalWrite (11,LOW);
  digitalWrite (8,LOW);
}</code></pre>
            <p>
                Both the full and half step code are within this program, switching achieved by setting the global flag to either FULL or HALF. Serial readout is tab-delineated, of the format: time [s], steps, current in coil A [mA], coil in current B [mA].
            </p>
        <div class="subhead small-caps" id="tests">
            <a href="#tests">Test procedure</a></div>
            <p>
                
            </p>
        <div class="subhead small-caps" id="results">
            <a href="#results">Test results</a></div>
            <p>
                
            </p>
            <img src="/img/AngularDisplacementVSTime.PNG" id="angDisp" alt="Angular displacement vs. time"/>
            <p>
                
            </p>
            <img src="/img/iHalfVSTime.PNG" id="iHalf" alt="Current in coils A and B over time in halfstep regime."/>
            <p>
                
            </p>
            <img src="/img/iFullVSTime.PNG" id="iFull" alt="Current in coils A and B over time in fullstep regime."/>
            <p>
                
            </p>
        <div class="subhead small-caps" id="motion">
            <a href="#motion">Loaded motion cycle</a></div>
            <p>
                Below pictured is the linear stage carrying a Mason jar, weighing in at 0.8kg. The program is triggered by an initial press of the limit switch, travels until hitting the aforementioned switch, and returning to its home position.
            </p>
            <div class="videodiv"><iframe src="https://www.youtube-nocookie.com/embed/DrpjgVJvdvU?modestrbranding=1&title=&showinfo=0&controls=0&mute=1&rel=0&fs=0&disablekb=1" frameborder="0" allow="accelerometer; encrypted-media; gyroscope;" class="video"></iframe></div>
        <div class=footer>
            <p>Zachary Weiss<br/>4 October 2020</p>
            <p>test</p>
        </div>
	</div>
</div>
</body>
</html>
<!-- 2020 Zachary Weiss -->